<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lector continuo (HID) → Ruta</title>
<link rel="preconnect" href="https://unpkg.com"/>
<style>
  :root{--bg:#0b0f14;--card:#121822;--ink:#e6edf3;--muted:#9fb0c8;--ok:#1db954;--err:#ff5c5c;--accent:#2d9cdb}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b0f14,#0f1622);color:var(--ink)}
  .wrap{max-width:1100px;margin:0 auto;padding:20px}
  h1{font-size:20px;margin:0 0 10px}
  .grid{display:grid;gap:16px}
  @media(min-width:900px){.grid{grid-template-columns:1.2fr .8fr}}
  .card{background:var(--card);border:1px solid #1d2838;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type=file],button,input[type=text],label.pill{border-radius:12px;border:1px solid #2a3750;background:#0c121b;color:var(--ink);padding:10px 12px}
  input[type=text]{min-width:320px;font-size:18px}
  button{cursor:pointer}
  .status{margin-top:10px;border-radius:12px;padding:12px;font-weight:700}
  .ok{background:rgba(29,185,84,.14);border:1px solid rgba(29,185,84,.35)}
  .err{background:rgba(255,92,92,.14);border:1px solid rgba(255,92,92,.35)}
  .warn{background:rgba(45,156,219,.14);border:1px solid rgba(45,156,219,.35)}
  .muted{color:var(--muted)}
  .table{width:100%;border-collapse:collapse;margin-top:8px}
  .table th,.table td{border-bottom:1px solid #243043;padding:6px;text-align:left}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#0c121b;border:1px solid #2a3650;color:#9fb0c8;font-size:12px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;min-width:260px;max-width:90vw;padding:12px 14px;border-radius:12px;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,.35);z-index:9999}
  .toast.ok{background:rgba(29,185,84,.98);color:#fff}
  .toast.err{background:rgba(255,92,92,.98);color:#fff}
  .hint{font-size:13px;color:var(--muted)}
  /* KPIs resumen CSV */
  .kpi-row{display:flex;gap:10px;flex-wrap:wrap;align-items:stretch;margin-top:10px}
  .kpi{flex:1 1 180px;background:#0c121b;border:1px solid #2a3750;border-radius:12px;padding:10px 12px}
  .kpi .title{font-size:12px;color:#9fb0c8;margin-bottom:4px}
  .kpi .value{font-weight:800;font-size:20px;line-height:1}
  /* Monitor de buffer (opcional) */
  .buffer{font-family:ui-monospace,Consolas,monospace;font-size:14px;color:#c3d2e7;background:#0c121b;border:1px dashed #2a3750;border-radius:8px;padding:6px 8px}
</style>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Lector continuo (USB/Bluetooth HID) → Ruta</h1>
  <div class="muted">
    Conecta el lector como <b>HID (modo teclado)</b>. CSV: <b>Columna A = referencia de manifiesto</b>, <b>Columna B = ID de la ruta</b>.  
    Cada escaneo responde automáticamente la ruta. Solo los éxitos se guardan.
  </div>

  <div class="grid">
    <!-- Izquierda: carga CSV + escaneo continuo -->
    <section class="card">
      <!-- Carga CSV -->
      <div class="row">
        <div>
          <label>Planilla (CSV)</label><br/>
          <input id="csv" type="file" accept=".csv,text/csv" />
          <div class="hint">Separador coma. Con o sin encabezado.</div>
        </div>
        <label class="pill"><input type="checkbox" id="beep" checked/> Beep</label>
        <label class="pill"><input type="checkbox" id="vibrate" checked/> Vibrar</label>
        <button id="clear-history">Limpiar historial</button>
        <span id="successCount" class="badge">0 éxitos</span>
      </div>

      <!-- Resumen del CSV -->
      <div id="csv-summary" class="kpi-row" style="display:none">
        <div class="kpi">
          <div class="title">Cantidad de paquetes</div>
          <div class="value" id="kpi-unique-manifests">0</div>
        </div>
        <div class="kpi">
          <div class="title">Cantidad de rutas</div>
          <div class="value" id="kpi-unique-routes">0</div>
        </div>
        <div class="kpi">
          <div class="title">Cantidad de paquetes duplicados</div>
          <div class="value" id="kpi-dup-manifests">0</div>
        </div>
      </div>

      <!-- Monitor de buffer (útil para testear que el lector escribe) -->
      <div class="row" style="margin-top:10px">
        <input id="manual" type="text" placeholder="(Opcional) Campo visible — el lector puede escribir aquí" autocomplete="off" />
        <div class="buffer" id="bufferView" title="Últimos caracteres leídos por el lector"></div>
      </div>

      <div id="status" class="status warn">Cargue el CSV y empiece a escanear. Sufijo recomendado en el lector: <b>ENTER</b>.</div>

      <div class="hint" style="margin-top:6px">
        Si su lector no envía ENTER/TAB, el sistema procesa automáticamente tras una <b>pausa breve</b>.
      </div>
    </section>

    <!-- Derecha: historial (solo éxitos) -->
    <aside class="card">
      <strong>Lecturas exitosas</strong>
      <div class="hint">Últimos 20 (los errores no se registran)</div>
      <table class="table" id="history">
        <thead><tr><th>Hora</th><th>Paquete</th><th>Ruta</th></tr></thead>
        <tbody></tbody>
      </table>
    </aside>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>

<script>
  // ===== Config y estado =====
  // Tiempos pensados para lectores láser ~260 escaneos/s
  const INACTIVITY_MS = 70;   // pausa breve tras tecleo para "fin de código"
  const DEDUPE_MS = 800;      // evita doble lectura si el haz permanece sobre el mismo código
  const MIN_LEN = 6;          // ignora lecturas demasiado cortas/accidentales
  const STRIP_AIM_ID = true;  // elimina prefijos tipo ]C1, ]A0 si tu lector los agrega

  // map: referencia de manifiesto (Col A) -> ID de ruta (Col B)
  let map = new Map();
  let okHistory = [];
  let successCount = 0;

  // Buffer global (captura a nivel de página)
  let scanBuffer = '';
  let inactivityTimer = null;
  let lastCode = ''; let lastWhen = 0;

  const $ = (id)=>document.getElementById(id);
  const statusEl = $('status');
  const toastEl = $('toast');
  const bufferView = $('bufferView');

  // ===== UI helpers =====
  function setStatus(msg, kind='warn'){
    statusEl.className = 'status ' + kind;
    statusEl.textContent = msg;
  }
  function toast(msg, kind='ok'){
    toastEl.textContent = msg;
    toastEl.className = 'toast ' + kind;
    toastEl.style.display = 'block';
    setTimeout(()=> toastEl.style.display='none', 1100);
  }
  function beep(){
    if(!$('beep').checked) return;
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type='square'; o.frequency.value=880; o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
      o.start();
      setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.05); o.stop(); ctx.close(); }, 110);
    }catch(e){}
  }
  function vibrate(){ if($('vibrate').checked && navigator.vibrate) navigator.vibrate(50); }
  function normalize(x){ return String(x||'').trim(); }

  // Sanitiza lo recibido del lector (quita controles y, opcionalmente, AIM ID)
  function sanitize(raw){
    let s = String(raw || '');
    // quita CR/LF/TAB y no imprimibles
    s = s.replace(/[\r\n\t]+/g, '').replace(/[^\x20-\x7E]/g, '');
    // quita prefijos AIM ID (p.ej., ]C1, ]A0, ]E0)
    if(STRIP_AIM_ID) s = s.replace(/^\][A-Z]\d/, '');
    return s.trim();
  }

  // ===== CSV (A = manifiesto, B = ruta) =====
  $('csv').addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    Papa.parse(f, {
      complete: (res)=>{
        const rows = res.data.filter(r=>r && r.length && r.some(c=>String(c).trim()!==''));
        if(!rows.length){ setStatus('CSV vacío.', 'err'); return; }
        const first = rows[0];
        const hasHeader = first.some(x => isNaN(Number(String(x).trim())) && String(x).trim().length>0);
        const data = hasHeader ? rows.slice(1) : rows;

        map.clear();
        const manifestList = [];
        const routeList = [];
        for(const r of data){
          const manifest = normalize(r[0]); // Col A
          const routeId  = normalize(r[1]); // Col B
          if(manifest){
            map.set(manifest, routeId || '');
            manifestList.push(manifest);
            routeList.push(routeId || '');
          }
        }

        // KPIs
        const uniqueManifests = new Set(manifestList).size;                  // Cantidad de paquetes
        const uniqueRoutes    = new Set(routeList.filter(x=>x!=='')).size;   // Cantidad de rutas
        const freq = Object.create(null);
        for(const m of manifestList){ freq[m] = (freq[m]||0) + 1; }
        let dupManifests = 0; for(const m in freq){ if(freq[m] > 1) dupManifests += (freq[m]-1); } // Duplicados

        $('kpi-unique-manifests').textContent = uniqueManifests;
        $('kpi-unique-routes').textContent    = uniqueRoutes;
        $('kpi-dup-manifests').textContent    = dupManifests;
        $('csv-summary').style.display = 'flex';

        setStatus(`CSV cargado (${uniqueManifests} paquetes únicos, ${uniqueRoutes} rutas). Escanee con el lector.`, 'ok');
        $('manual').focus(); // opcional: campo visible
      },
      error: ()=> setStatus('Error al leer el CSV.', 'err')
    });
  });

  // ===== Captura global del lector (HID) =====
  function scheduleAutoProcess(){
    if(inactivityTimer) clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(flushScanBuffer, INACTIVITY_MS);
  }
  function appendToBuffer(ch){
    scanBuffer += ch;
    bufferView.textContent = scanBuffer;               // monitor visible
    const manual = $('manual');
    if(document.activeElement !== manual) manual.value = scanBuffer; // reflejo opcional
    scheduleAutoProcess();
  }
  function flushScanBuffer(){
    const code = sanitize(scanBuffer);
    scanBuffer = '';
    bufferView.textContent = '';
    $('manual').value = '';
    if(!code || code.length < MIN_LEN) return;

    const now = Date.now();
    if(code === lastCode && (now - lastWhen) < DEDUPE_MS) return; // evita doble
    lastCode = code; lastWhen = now;

    handleDetected(code);
  }

  // Captura de teclas: ENTER/TAB => procesa, Backspace edita, resto agrega
  document.addEventListener('keydown', (ev)=>{
    if(map.size === 0) return;                   // sin CSV, ignorar
    if(ev.ctrlKey || ev.altKey || ev.metaKey) return;

    if(ev.key === 'Enter' || ev.key === 'Tab'){
      ev.preventDefault();
      flushScanBuffer();
      return;
    }
    if(ev.key === 'Backspace'){
      scanBuffer = scanBuffer.slice(0, -1);
      bufferView.textContent = scanBuffer;
      const manual = $('manual');
      if(document.activeElement !== manual) manual.value = scanBuffer;
      scheduleAutoProcess();
      return;
    }
    if(ev.key && ev.key.length === 1){
      appendToBuffer(ev.key);
      if(ev.key !== ' ') ev.preventDefault();   // evita scroll accidental
    }
  }, true);

  // Pegar también funciona
  document.addEventListener('paste', (ev)=>{
    if(map.size === 0) return;
    const txt = (ev.clipboardData || window.clipboardData).getData('text') || '';
    if(txt){
      ev.preventDefault();
      scanBuffer += txt;
      bufferView.textContent = scanBuffer;
      scheduleAutoProcess();
    }
  });

  // ===== Resultado (historial solo éxitos) =====
  function addSuccess(code, route){
    const tb = $('history').querySelector('tbody');
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date().toLocaleTimeString()}</td><td>${code}</td><td>${route}</td>`;
    tb.insertBefore(tr, tb.firstChild);
    while(tb.rows.length>20) tb.deleteRow(tb.rows.length-1);

    okHistory.push({ t:Date.now(), code, route });
    successCount++;
    $('successCount').textContent = `${successCount} éxitos`;
  }

  function handleDetected(codeRaw){
    const clean = sanitize(codeRaw);
    const route = map.get(clean);
    if(route !== undefined){
      setStatus(`Ruta: ${route || '(sin ruta)'}`, 'ok');
      toast(`✔ ${clean} → ${route || '(sin ruta)'}`, 'ok');
      beep(); vibrate();
      addSuccess(clean, route || '(sin ruta)');
    }else{
      setStatus('Código no encontrado en el CSV.', 'err');
      toast(`✖ ${clean} no encontrado`, 'err');
      beep(); // no se registra error
    }
  }

  // Limpiar historial
  $('clear-history').addEventListener('click', ()=>{
    $('history').querySelector('tbody').innerHTML = '';
    okHistory = []; successCount = 0;
    $('successCount').textContent = '0 éxitos';
    setStatus('Historial limpiado.', 'warn');
  });
</script>
</body>
</html>
